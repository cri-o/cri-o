package resourcestore

import (
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

const sleepTimeBeforeCleanup = 1 * time.Minute

// ResourceStore is a structure that saves information about a recently created resource.
// Resources can be added and retrieved from the store. A retrieval (Get) also removes the Resource from the store.
// The ResourceStore comes with a cleanup routine that loops through the resources and marks them as stale, or removes
// them if they're already stale, then sleeps for `timeout`.
// Thus, it takes between `timeout` and `2*timeout` for unrequested resources to be cleaned up.
// Another routine can request a watcher for a resource by calling WatcherForResource.
// All watchers will be notified when the resource has successfully been created.
type ResourceStore struct {
	resources map[string]*Resource
	timeout   time.Duration
	sync.Mutex
}

// Resource contains the actual resource itself (which must implement the IdentifiableCreatable interface),
// as well as stores function pointers that pertain to how that resource should be cleaned up.
type Resource struct {
	resource     IdentifiableCreatable
	cleanupFuncs []func()
	watchers     []chan struct{}
	stale        bool
	name         string
}

// IdentifiableCreatable are the qualities needed by the caller of the resource.
// Once a resource is retrieved, SetCreated() will be called, indicating to the server
// that resource is ready to be listed and operated upon, and ID() will be used to identify the
// newly created resource to the server.
type IdentifiableCreatable interface {
	ID() string
	SetCreated()
}

// New creates a new ResourceStore, with a default timeout, and starts the cleanup function
func New() *ResourceStore {
	return NewWithTimeout(sleepTimeBeforeCleanup)
}

// NewWithTimeout is used for testing purposes. It allows the caller to set the timeout, allowing for faster tests.
// Most callers should use New instead.
func NewWithTimeout(timeout time.Duration) *ResourceStore {
	rc := &ResourceStore{
		resources: make(map[string]*Resource),
		timeout:   timeout,
	}
	go rc.cleanupStaleResources()
	return rc
}

// cleanupStaleResources is responsible for cleaning up resources that haven't been gotten
// from the store.
// It runs on a loop, sleeping `sleepTimeBeforeCleanup` between each loop.
// A resource will first be marked as stale before being cleaned up.
// This means a resource will stay in the store between `sleepTimeBeforeCleanup` and `2*sleepTimeBeforeCleanup`.
// When a resource is cleaned up, it's removed from the store and its cleanupFuncs are called.
func (rc *ResourceStore) cleanupStaleResources() {
	for {
		time.Sleep(rc.timeout)
		resourcesToReap := []*Resource{}
		rc.Lock()
		for name, r := range rc.resources {
			if r.stale {
				resourcesToReap = append(resourcesToReap, r)
				delete(rc.resources, name)
			}
			r.stale = true
		}
		// no need to hold the lock when running the cleanup functions
		rc.Unlock()

		for _, r := range resourcesToReap {
			logrus.Infof("cleaning up stale resource %s", r.name)
			for _, f := range r.cleanupFuncs {
				f()
			}
		}
	}
}

// Get attempts to look up a resource by its name.
// If it's found, it's removed from the store, and it is set as created.
// Get returns an empty ID if the resource is not found,
// and returns the value of the Resource's ID() method if it is.
func (rc *ResourceStore) Get(name string) string {
	rc.Lock()
	defer rc.Unlock()

	r, ok := rc.resources[name]
	if !ok {
		return ""
	}
	delete(rc.resources, name)
	r.resource.SetCreated()
	return r.resource.ID()
}

// Put takes a unique resource name (retrieved from the client request, not generated by the server)
// a newly created resource, and functions to cleanup that newly created resource.
// It adds the Resource to the ResourceStore, as well as starts a go routine that is responsible for cleaning up the
// resource if the server has not gotten another request for it (i.e. if Get has not been called).
// Put expects `name`s passed to it to be unique. If a duplicate `name` is detected, it returns an error.
func (rc *ResourceStore) Put(name string, resource IdentifiableCreatable, cleanupFuncs []func()) error {
	rc.Lock()
	defer rc.Unlock()

	if r, ok := rc.resources[name]; ok {
		return errors.Errorf("failed to add entry %s to ResourceCache; entry already exists", name)
	}
	rc.resources[name] = &Resource{
		resource:     resource,
		cleanupFuncs: cleanupFuncs,
		name:         name,
	}

	return nil
}
